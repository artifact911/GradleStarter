У нас есть два способа собрать jar.

 1. FatJar (собирает все зависимости внутри себя):

    1. Мы можем запустить таску assemble или jar. Запустим.
    2. Перейдем в cmd в папку с артефактом
    3. Запустим нашу jar
            java -jar .\gradle-starter.jar
        Получаем
            no main manifest attribute, in .\gradle-starter.jar

    Если мы разархивируем jar то там будет в папке META-INF файлик MANIFEST.MF. Что бы наш jar можно было запустить,
    в этом файле нужно указать Main-Class: com.art.HelloWorld. Но нам нужно это сделать так, чтобы при выполнении
    таски jar эта строчка оказалась внутри нашего файла MANIFEST.MF. И для этого нам нужно подправить нашу задачу jar.
    Идем в build.gradle и
        jar {
            manifest {
                attributes 'Main-Class': 'com.art.HelloWorld'
            }
        }

    4. Пересоберем jar и там будеи наш норм манифест. Но теперь запустив, мы получим ошибку о том, что он не знает
        о других зависимостях (спринг в данном случае). Нам нужно эти все зависимости подложить в нашу jar.
        Снова редачим jar таску которая позволяет при момощи from() добавлять файлы зависимостей. А файлы зависимостей
        мы можем попросить у конфигурации:
            jar {
                manifest {
                    attributes 'Main-Class': 'com.art.HelloWorld'
                }
                from (configurations.runtimeClasspath.files)
            }
        Но это ничего не даст, тк это jar-ки так и будет лежать в архивах и ошибка будет та же. Фиксим при помощи:
            jar {
                manifest {
                    attributes 'Main-Class': 'com.art.HelloWorld'
                }

                // пришлось заюзать, ибо при копировании ругался на одинаковые названия каких-то txt
                duplicatesStrategy(DuplicatesStrategy.EXCLUDE)

                // collect отдал коллекцию jar а zipTree() распаковал их
                from (configurations.runtimeClasspath.files.collect{project.zipTree(it)})
            }
        Запускаем - все работает!!!

 2. Более предпочтительный вариант
        В директории нашего установленного gradle есть директория lib в которой собственно и лежат все наши зависимости
        которых накачал себе gradle. В итоге, мы можем сделать нашу jar пустой (без сторонних зависимостей), а в
        отдельной директории lib будут все наши зависимости. И конечно же для начала, нам нужно создать такую
        директорию lib. Обычно она находится в той же самой директрии, где мы запускаем наш проект. Например: у нас есть
        в билде директория libs откуда мы и запускам нашу jar и там мы можем создать директорию lib и туда положим
        все наши сторонние зависимости. И для этого нам нужно создать таску, которая будет копировать наши зависимсоти в
         директорию lib.

         1. // таске даем имя и указываем тип Copy. Таким образов у нас будут все методы из таски Copy
                task copyAllDependencies(type: Copy) {

         2. // теперь нужно указать откуда брать зависимости и куда писать
                  from(configurations.runtimeClasspath.files)
                  into("$buildDir/libs/lib")
         }

         3. Теперь, чтобы не вызывать ее вручную, мы может привязать ее к жизенному циклу нашего приложения.
                И в данном случае мы можем ее привязать к таске assemble либо jar
                jar.dependsOn copyAllDependencies

         4. Теперь в папке libs у нас есть пакет lib с нашими зависимостоями. А разархивировав jar мы увидим, что там
                наших зависимостей нет. Но запустив java -jar gradle-starter.jar мы видим проблему - не работает.
                Все потому, что теперь в MANIFEST.MF нужно указать эту директорию lib через свойство Class-Path
                перечислив все наши зависимости через пробел

                jar {

                // достанем имена всех зависимсотей в виде строки
                 def jars = configurations.runtimeClasspath.files.collect { "lib/$it.name" }
                    manifest {
                        attributes 'Main-Class': 'com.art.HelloWorld'

                        // соединяем в одну строку и говорим, что разделяем пробелом
                        attributes 'Class-Path': jars.join(' ')
                    }
                }

         5. Собираем. Запускаем - все работает!!!